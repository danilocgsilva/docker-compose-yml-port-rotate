#!/bin/bash

COMMAND_NAME=dcpr

VERSION=0.0.1

# This function needs an argument pointing to a file, where the analysis will
#   happen
# Counts how many lines exists with port data 
#
# Receives a file path with content
# Returns a number
span_lines_for_ports() {
    FILE=$1

    next_line_number() {
        OFFSET_LINE=$1
        FILE=$2
        REAL_OFFSET_LINE=$(expr $OFFSET_LINE + 1)
        starting_spaces_count "$(sed -n $REAL_OFFSET_LINE\p $FILE)"
    }

    HEADER_LINE_NUMBER=$(expr $(find_ports_starting_line $FILE) + 1)
    HEADER_STRING=$(sed -n $HEADER_LINE_NUMBER\p $FILE)
    HEADER_LINE_SPACING=$(starting_spaces_count "$HEADER_STRING")
    LOOP_NUMBER=$HEADER_LINE_NUMBER

    SPAN_COUNT=0
    while [ $(next_line_number $LOOP_NUMBER $FILE) -gt $HEADER_LINE_SPACING ]
    do
       LOOP_NUMBER=$(expr $LOOP_NUMBER + 1)
       SPAN_COUNT=$(expr $SPAN_COUNT + 1)
    done
    
    echo $SPAN_COUNT
}

# Receives string
# Return number
function starting_spaces_count() {
    EXPRESSION="$1"
    NON_STARTING_SPACES_COUNT=$(echo "$EXPRESSION" | sed "s/^[[:space:]]*//g" | wc -c)
    FULL_COUNT=$(echo "$EXPRESSION" | wc -c)
    expr $FULL_COUNT - $NON_STARTING_SPACES_COUNT
}

# Check where ports starts in line number
#
# Return a number
find_ports_starting_line() {
    declare -a local OCORRENCIES_LINES
    IFS_OLD=$IFS
    IFS=$'\n'

    FILE=$1
    COUNT=0
    PORTS_STARTING_LINE=0
    FILE_COUNT_LINES=$(cat $FILE | wc -l)

    for i in $(seq $FILE_COUNT_LINES)
    do
        STRING_LOOP=$(sed -n $i\p $FILE)
        if echo $STRING_LOOP | grep "ports:" > /dev/null 2>&1
        then
            PORTS_STARTING_LINE=$COUNT
        fi
        COUNT=$(expr $COUNT + 1)
    done

    OCORRENCIES_LINES+=($PORTS_STARTING_LINE)
    
    echo "${OCORRENCIES_LINES[@]}"
    IFS=$IFS_OLD
}

# Transform a port value entry to add the value to one, so does not
#   conflits with the previous port
#
# Receives a string to have its ports values rotated
# return string
port_offset() {
    INPUT="$1"
    BASE=$(echo "$INPUT" | cut -f1 -d: | cut -f2 -d\")
    PLUSVALUE=$(expr $BASE + 1)
    echo "$INPUT" | sed "s/$BASE/$PLUSVALUE/1"
}

# main method
dcpr () {
    if [ ! -f $1 ] || [ -z $1 ]; then
        if [ ! -f docker-compose.yml ]; then
            echo "Cannot perform the task. You needs be in a folder with a docker-compose.yml file (tipically, the root from a Docker project) ot provides a docker-compose file as the first argument."
            exit 1
        fi
        FILE_DOCKER=docker-compose.yml
    else
        FILE_DOCKER=$1
    fi

    HEADER_LINE_NUMBER=$(find_ports_starting_line $FILE_DOCKER)
    SPAN_LINES=$(span_lines_for_ports $FILE_DOCKER)
    for i in $(seq $SPAN_LINES); do
        LINE_NUMBER_TARGET=$(expr $i + $HEADER_LINE_NUMBER + 1)
        ITERATION_CONTENT=$(sed -n $LINE_NUMBER_TARGET\p $FILE_DOCKER)
        ITERATION_CONTENT=$(echo $ITERATION_CONTENT | cut -f2 -d" ")
        RENEWED_CONTENT=$(port_offset $ITERATION_CONTENT)
        sed -i $LINE_NUMBER_TARGET\s/$ITERATION_CONTENT/$RENEWED_CONTENT/1 $FILE_DOCKER
    done
}

## detect if being sourced and
## export if so else execute
## main function with args
if [[ ${BASH_SOURCE[0]} != $0 ]]; then
  export -f ${COMMAND_NAME}
else
  ${COMMAND_NAME} "${@}"
fi
